
## 效能分析

**1.void Sort()**

運作：sort()：O(t log t)合併重複次方與移除 0 項：O(t)

時間複雜度：O(t log t)

空間複雜度：O(1)（就地排序）

**2.void STerm(float coef, int exp)**

運作：用線性搜尋判斷是否已有相同次方（O(terms)）若沒有，插入新項（O(1)），若空間不足時呼叫 NewArray()（可能觸發 O(terms) 的搬移）

時間複雜度：平均情況：O(t)，最壞情況（空間擴充）：O(t)

空間複雜度：O(t)（動態陣列）

**3.Polynomial Add(const Polynomial& n) const**

運作：對兩個多項式的每一項呼叫 addTerm()本身需要線性搜尋 (O(t))，所以總共約有：
O(m * (平均搜尋長度)) + O(n * (平均搜尋長度))≈ O(m^2 + n^2)（若項數接近）最後呼叫 Sort()（O(t log t)）

時間複雜度：
𝑂((𝑚+𝑛)^2)

空間複雜度：
O(m + n)（儲存結果多項式）

**4.Polynomial Mult(const Polynomial& n) const**

運作：雙層迴圈 m × n 次相乘（O(m·n)，每次乘積都呼叫 addTerm()（線性搜尋，O(t)，若結果多項式項數接近 m·n，則：
O(m*n * t) ≈ O(m^2 * n^2) 最壞情況，最後 Sort()：O(t log t)

時間複雜度：平均情況：O(m·n·t) ≈ O(m² n²) 最壞情況，若合併有效（少重複次方）約 O(m·n)

空間複雜度：
O(m + n + m·n)（儲存中間結果）

**5.float Eval(float f) const**

運作：單一迴圈，計算每項 coef * powf(x, exp)，而 powf() 通常為 O(1)（硬體或快速冪），因此整體線性。

時間複雜度：O(t)

空間複雜度：O(1)

## 測試與驗證

| 測試案例 | P1(x) | P2(x) | x | Add | Mult | Eval |
|---------|-------|-------|---| ----|----- |--------|
| 測試一   | 3x^2 |  x^2 | 1       | P1 + P2 =4x^2 |P1 * P2 =3x^4 |P1(1) = 3 ,P2(1) = 1 |
| 測試二   | -x^2 + 3x + 2 | -2x^2 + x| 2        | P1 + P2 = -3x^2 + 4x + 2 |P1 * P2 = 2x^4 - 7x^3 - x^2 + 2x |P1(2) = 4 ,P2(2) = -6 |
| 測試三   | x^9999 | 0        | 1        | P1 + P2 = x^9999 |P1 * P2 = 0|P1(1) = 1,P2(1) = 0 |


## 心得

1. 在記憶體管理的過程中發現了手動 new、delete、擴充容量、複製建構子、解構子的重要性，整個流程是以 C++「動態記憶體」為核心的控制，且將來寫大型專案或考試遇到考「深拷貝 / 淺拷貝」，時也將不是問題這程式的結構就是經典範例，而在解決四則運算的同時擴充記憶體其實是一個非常好用的方法，因為在不知道最終結果需求空間時可以隨時分配空間，在分配的時候會運用到```<algorithm>``` 中的sort()排序以免在最後空間浪費的情況發生。

## 申論及開發報告

### 使用物件導向運算子負載及動態記憶體控制

1. **實際的分析**
 
 **a.程式功能分析**
 
 這份程式主要設計目的：以「物件導向」方式實作多項式（Polynomial）的：

