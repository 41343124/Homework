#include <iostream>//此題為讓S()集合運用遞迴函式來架構,並輸出底下的所有子集合
//概念:運用記憶體配置以及遞迴函式來輸出每層的元素組合,我是以金字塔(梯形)的方式來排出每層所有的組合
using namespace std;

int m, n, h = 0;
//...................................................................................................................
int powerset(int j, int z, char* p) {//此遞迴函式的終止條件為判斷j暫存器是否有走完所有階層
	if (j < m) {//判斷式
		n = z;//此n為虛擬記錄點用來輸出每一層的元素
		int s = 0, v = z;
		while (s < m && v < m) {
			while (n < m) {
				for (int i = n - 1; i != -1; i--) {//此for是用來真側是否有相同的元素
					if (p[i] == p[n]) {
						h = 1;//h = 0代表無,h = 1代表有
					}
				}
				if (h != 1) {
					cout << ", (";
					for (int i = s; i < v; i++) {
						cout << p[i] << ",";
					}
					cout << p[n];
					cout << ")";
				}
				n += 1;//虛擬元素加一
				h = 0;
			}
			if (s < m) {
				v += 1;
				n = v;
			}
			s += 1;
		}
		j += 1;//執行完跳入下一層
		z += 1;//實際元素加一
		return powerset(j, z, p);//將現在資料傳入下一層
	}
}
//...................................................................................................................
void main() {
	cout << "請輸入需要多少元素空間: ";//先規定此集合內有多少元素,用來架構動態記憶體空間
	cin >> m;
	cout << "請輸入S的所有元素: ";
	char* p = new char[m];//用記憶體配置來儲存使用者輸入的集合元素
	for (int i = 0; i < m; i++) {//補充:因為C++會自動省略空白鍵所以不用加get()或是getchar()
		cin >> p[i];
	}
	cout << "powerset(S)={ ()";//輸出格式,順便輸出空字元
	for (int j = 0; j < m; j++) {//輸出最頂端單一元素的組合 EX.(a),(b)......
		for (int i = j - 1; i != -1; i--) {//此for是用來真側是否有相同的元素
			if (p[i] == p[j]) {
				h = 1; //h = 0代表無,h = 1代表有
			}
		}
		if (h != 1) {
			cout << ",(" << p[j] << ")";
		}
		h = 0;
	}
	int j = 1, z = 1;//計數器j以及z用來記錄階層數以及每個元數的走向
	char* P = p;//用指標P來傳址p動態配置
	powerset(j, z, P);//呼叫遞迴函式
	cout << " }";
	delete[] p;//記憶體空間回收
}
