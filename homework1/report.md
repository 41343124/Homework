
# 41343124

## 作業一 .1(Ackermann Function)

## 解題說明

本題要求使用遞迴函式,以及非遞迴函式實作。

### 解題策略

1. 遞迴函式:
   使用一般的遞迴解法 m和n是否等於0來判斷
2. 非遞迴函式:
   使用推疊空間來記錄最內層的資料並計算,最後在計算外層的資料(類似逆向撥洋蔥)

## 程式實作

### IDE:
Microsoft Visual Studio 2019 C++

遞迴函式：

```cpp
#include <iostream>//此題為ackermann function的遞迴解法
using namespace std;
//...........................................................................
unsigned long long A(unsigned int a, unsigned int b) {//雖使用unsigned long long但還是有一定的機會爆掉 ! ! !
	if (a == 0) {//當m=0時,輸出n+1
		return b + 1;
	}
	else if (b == 0) {//當n=0時,再次呼叫函式A()同時令傳入的m-1,n+1
		return A(a - 1, b + 1);
	}
	else {
		return A(a - 1, A(a, b - 1));//m和n接不等於0時,呼叫函式A().左參數為m-1,右參數為函式A(m,n-1)
	}
}
//...........................................................................
void main() {
	unsigned int m, n;
	cin >> m >> n;
	cout << A(m, n);
}

```
非遞迴函式：

```cpp
#include <iostream>// 前言:以下指令非完全自己架構出來的有部分程式用法與網路上相似但並非抄襲 ! ! ! 來源處Google 而非生成式AI
                   // 註解皆為本人 四資工二甲 41343124 張豈睿 標註
                   //概念:使用推疊空間(逆向撥洋蔥)來計算最內層的資料,最後在計算外層的資料

#include <stack>//<stack> 指令是內建的堆疊函式庫 EX: puch(),pop(), empty(),top(),size()......
                //而堆疊大小取決於記憶體大小與執行的環境限制

using namespace std;
//...........................................................................................
unsigned long long ackermann(unsigned int a, unsigned int b) {//雖使用unsigned long long但還是有一定的機會爆掉
    stack<unsigned int> A;
    A.push(a);

    while (!A.empty()) {//empty()用於確認堆疊空間內是否還有資料,無資料代表計算結束
        a = A.top();//top()查看堆疊最上層的資料,如果a和b接不等於0時使用top()將最內層的A先行計算避免執行錯誤 A(m-1,A(m,n-1))
        A.pop();//將以確認好的最上層資料傳給暫存器a後將最上層砍掉,如果第一個判斷成立即可算下一層,不成立就必須重複執行

        if (a == 0) {//m=0,輸出n+=1
            b += 1;
        }
        else if (b == 0) {//n=0,A(m-1,n+1)
            A.push(a - 1);
            b += 1;
        }
        else {//m和n接不等於0,A(m-1,A(m,n-1))
            A.push(a - 1);//先放最外層的A
            A.push(a);//先算最內層的A
            b = b - 1;
        }
    }
    return b;
}
//...........................................................................................
void main() {
    unsigned int m, n;
    cin >> m >> n;
    cout << ackermann(m, n);
}
```

## 效能分析
遞迴函式：
1. 空間複雜度：空間複雜度大約為 $O(2^n)$。
2. 時間複雜度：程式的時間複雜度大約為 $O(2+2*A((a-1)*A(a,b-1)))$。

遞迴函式：
1. 空間複雜度：空間複雜度大約為 $O(\log n)$。
2. 時間複雜度：程式的時間複雜度大約為 $O(2+2*A((a-1)*A(a,b-1)))$。


## 測試與驗證

### 測試案例 (遞迴/非遞迴)

| 測試案例 | 輸入參數 $m,n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $m = 0,n = 3$ | 4        | 4        |
| 測試二   | $m = 1,n = 0$ | 2        | 2        |
| 測試三   | $m = 2,n = 1$ | 5        | 5        |
| 測試四   | $m = 3,n = 2$ | 29       | 29       |
| 測試五   | $m = 5,n = 1$ | 異常拋出  | 異常拋出  |

### 結論

1. 僅管使用了堆疊以及unsigned long long但還是有一定的機會爆掉。
2. 程式所能執行的範圍大約在 m=4,n=1以上時就無法執行了不管是遞迴或是非遞迴，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$m = 0$、$ m和n不等於0 $），等驗證程式的正確性。

## 申論及開發報告

### 選擇堆疊的原因

1. **程式碼邏輯簡單**  
   Stack的寫法相當於自己管理堆疊且空間計算上能以最內層的資料計算最後在計算外層的資料避免執行錯誤。  
   例如：  
      empty()用於確認堆疊空間內是否還有資料,無資料代表計算結束。
      top()查看堆疊最上層的資料,如果a和b接不等於0時使用top()將最內層的A先行計算。
      m和n接不等於0的話:
        A.push(a - 1);//先放最外層的A
        A.push(a);//先算最內層的A
        b = b - 1;

2. **推疊的分析**  
   堆疊演算法（Stack） 是一種有序串列（即一群相同資料型態的組合），具有「後進先出」（Last In First Out, LIFO）的特性,故其所有的動作、資料的處理方式均在同一邊進行,
   同時實現了在大量測資運行時避免使用遞迴空間的浪費空間,而是把所有側資放放在同一個空間中。
   
3. **優缺點**
   優點：
   不用系統遞迴呼叫，因此可處理較大參數。
   控制流程更靈活。
 
   缺點：
   寫法較複雜。
   若數值太大,堆疊大小仍可能不足。

4. **理想推演**
   雖然每總解法都大同小異但在時間與空間的限制下要實現是有一定的複雜但下列這些方法是我找到有趣的解法之一 ! !
   1.利用「已知規律」或「特殊情況」進行公式化。
   2.include <map> 。
   3.鏈結串列節省空間。

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

## 作業一 .2(Powerset)

## 解題說明

本題要求使用以遞迴函式的方式來輸出S()集合,而S()集合是由 n個元素所組成的。

Ex. n =3 , S =(a,b,c) , powerset(S) =?
A :{ (),(a),(b),(c), (a,b), (a,c), (b,c), (a,b,c) } 

### 解題策略

運用記憶體配置以及遞迴函式來輸出每層的元素組合,我是以金字塔(梯形)的方式來排出每層所有的組合,
在程式中的n = z; 此n為虛擬記錄點用來輸出每一層的元素,而z則是實際的紀錄點每次走完一層 z+=1,
並且將記錄下來的z座標傳入下一次遞迴函數powerset(j, z, p)中,此圖會有一個缺點當側資有重複時,
輸出也會重複,所以要使用一個迴圈來排除重複結果。


## 程式實作

### IDE:
Microsoft Visual Studio 2019 C++

```cpp
#include <iostream>//此題為讓S()集合運用遞迴函式來架構,並輸出底下的所有子集合
//概念:運用記憶體配置以及遞迴函式來輸出每層的元素組合,我是以金字塔(梯形)的方式來排出每層所有的組合
using namespace std;

int m, n, h = 0;
//...................................................................................................................
int powerset(int j, int z, char* p) {//此遞迴函式的終止條件為判斷j暫存器是否有走完所有階層
	if (j < m) {//判斷式
		n = z;//此n為虛擬記錄點用來輸出每一層的元素
		int s = 0, v = z;
		while (s < m && v < m) {
			while (n < m) {
				for (int i = n - 1; i != -1;i--) {//此for是用來真側是否有相同的元素
					if (p[i]==p[n]) {
						h = 1;//h = 0代表無,h = 1代表有
					}
				}
				if (h != 1) {
					cout << ", (";
					for (int i = s; i < v; i++) {
						cout << p[i] << ",";
					}
					cout << p[n];
					cout << ")";
				}
				n += 1;//虛擬元素加一
				h = 0;
			}
			if (s < m) {
				v += 1;
				n = v;
			}
			s += 1;
		}
		j += 1;//執行完跳入下一層
		z += 1;//實際元素加一
		return powerset(j, z, p);//將現在資料傳入下一層
	}
}
//...................................................................................................................
void main() {
	cout << "請輸入需要多少元素空間: ";//先規定此集合內有多少元素,用來架構動態記憶體空間
	cin >> m;
	cout << "請輸入S的所有元素: ";
	char* p = new char[m];//用記憶體配置來儲存使用者輸入的集合元素
	for (int i = 0; i < m; i++) {//補充:因為C++會自動省略空白鍵所以不用加get()或是getchar()
		cin >> p[i];
	}
	cout << "powerset(S)={ ()";//輸出格式,順便輸出空字元
	for (int j = 0; j < m; j++) {//輸出最頂端單一元素的組合 EX.(a),(b)......
		for (int i = j - 1; i != -1; i--) {//此for是用來真側是否有相同的元素
			if (p[i] == p[j]) {
				h = 1; //h = 0代表無,h = 1代表有
			}
		}
		if (h != 1) {
			cout << ",(" << p[j] << ")";
		}
		h = 0;
	}
	int j = 1, z = 1;//計數器j以及z用來記錄階層數以及每個元數的走向
	char* P = p;//用指標P來傳址p動態配置
	powerset(j, z, P);//呼叫遞迴函式
	cout << " }";
	delete[] p;//記憶體空間回收
}

```

## 效能分析
1. 空間複雜度：空間複雜度大約為 $O(\log n)$。
2. 時間複雜度：程式的時間複雜度大約為 $O(m^3*n^2)$。

## 測試與驗證

### 測試案例 (遞迴/非遞迴)

| 測試案例 | 輸入參數 $m,n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $S =(a,b,c)$ | { (),(a),(b),(c), (a,b), (a,c), (b,c), (a,b,c) } | { (),(a),(b),(c), (a,b), (a,c), (b,c), (a,b,c) } |
| 測試二   | $S =(a,b,b)$ | { (),(a),(b), (a,b) } | { (),(a),(b), (a,b) } |
| 測試三   | $S =(a,b,c,d)$ | { (),(a),(b),(c),(d), (a,b), (a,c), (a,d), (b,c), (b,d), (c,d), (a,b,c), (a,b,d), (b,c,d), (a,b,c,d) } | { (),(a),(b),(c),(d), (a,b), (a,c), (a,d), (b,c), (b,d), (c,d), (a,b,c), (a,b,d), (b,c,d), (a,b,c,d) } |


### 結論

1. 此程式的處理雖然精準可以按照預設的元素輸出不須排序但相對的時間複雜度過於高基本上是用時間換空間的概念。
2. 運用虛擬紀錄點雖然是一個錯的想法但還是浪費太多的空間且複雜度提高不太划算的感覺。  
3. 測試案例涵蓋了邊界情況重複項的排除，驗證程式的正確性。Ex. (a,c,c) (c,d,f,f)......

## 申論及開發報告

### 選擇梯形架構的原因

1. **程式碼架構好了解**  
   運用類似行與列的空間配置來走過每個元素且還不會重複因為每筆側資都在記錄完以後就立即輸出了。

3. **實際的分析**  
   雖然虛擬紀錄點是一個不錯的解決方法但前提是在輸入員數必須是經過排序過得,
   雖然此問題很好解決只要運用字元的ASCII碼大小比較就可以解決,但這樣子時間複雜度又會提高。
   
4. **優缺點**
   優點：
   程式精準度提高。
   紀錄每個位置的虛擬記憶體。
 
   缺點：
   寫法較複雜。
   用"時間換空間"方法消耗太多處理時間。

5. **理想推演**
   使用樹狀圖來分析是否有相同元素來分之判斷
