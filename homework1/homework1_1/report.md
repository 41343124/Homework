
# 41343124

## 作業一 .1(Ackermann Function)

## 解題說明

本題要求使用遞迴函式,以及非遞迴函式實作。

### 解題策略

1. 遞迴函式:
   使用一般的遞迴解法 m和n是否等於0來判斷
2. 非遞迴函式:
   使用推疊空間來記錄最內層的資料並計算,最後在計算外層的資料(類似逆向撥洋蔥)

## 程式實作

### IDE:
Microsoft Visual Studio 2019 C++

遞迴函式：

```cpp
#include <iostream>//此題為ackermann function的遞迴解法
using namespace std;
//...........................................................................
unsigned long long A(unsigned int a, unsigned int b) {//雖使用unsigned long long但還是有一定的機會爆掉 ! ! !
	if (a == 0) {//當m=0時,輸出n+1
		return b + 1;
	}
	else if (b == 0) {//當n=0時,再次呼叫函式A()同時令傳入的m-1,n+1
		return A(a - 1, b + 1);
	}
	else {
		return A(a - 1, A(a, b - 1));//m和n接不等於0時,呼叫函式A().左參數為m-1,右參數為函式A(m,n-1)
	}
}
//...........................................................................
void main() {
	unsigned int m, n;
	cin >> m >> n;
	cout << A(m, n);
}

```
非遞迴函式：

```cpp
#include <iostream>// 前言:以下指令非完全自己架構出來的有部分程式用法與網路上相似但並非抄襲 ! ! ! 來源處Google 而非生成式AI
                   // 註解皆為本人 四資工二甲 41343124 張豈睿 標註
                   //概念:使用推疊空間(逆向撥洋蔥)來計算最內層的資料,最後在計算外層的資料

#include <stack>//<stack> 指令是內建的堆疊函式庫 EX: puch(),pop(), empty(),top(),size()......
                //而堆疊大小取決於記憶體大小與執行的環境限制

using namespace std;
//...........................................................................................
unsigned long long ackermann(unsigned int a, unsigned int b) {//雖使用unsigned long long但還是有一定的機會爆掉
    stack<unsigned int> A;
    A.push(a);

    while (!A.empty()) {//empty()用於確認堆疊空間內是否還有資料,無資料代表計算結束
        a = A.top();//top()查看堆疊最上層的資料,如果a和b接不等於0時使用top()將最內層的A先行計算避免執行錯誤 A(m-1,A(m,n-1))
        A.pop();//將以確認好的最上層資料傳給暫存器a後將最上層砍掉,如果第一個判斷成立即可算下一層,不成立就必須重複執行

        if (a == 0) {//m=0,輸出n+=1
            b += 1;
        }
        else if (b == 0) {//n=0,A(m-1,n+1)
            A.push(a - 1);
            b += 1;
        }
        else {//m和n接不等於0,A(m-1,A(m,n-1))
            A.push(a - 1);//先放最外層的A
            A.push(a);//先算最內層的A
            b = b - 1;
        }
    }
    return b;
}
//...........................................................................................
void main() {
    unsigned int m, n;
    cin >> m >> n;
    cout << ackermann(m, n);
}
```

## 效能分析
遞迴函式：
1. 空間複雜度：空間複雜度大約為 $O(2^n)$。
2. 時間複雜度：程式的時間複雜度大約為 $O(2+2*A((a-1)*A(a,b-1)))$。

遞迴函式：
1. 空間複雜度：空間複雜度大約為 $O(\log n)$。
2. 時間複雜度：程式的時間複雜度大約為 $O(2+2*A((a-1)*A(a,b-1)))$。


## 測試與驗證

### 測試案例 (遞迴/非遞迴)

| 測試案例 | 輸入參數 $m,n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $m = 0,n = 3$ | 4        | 4        |
| 測試二   | $m = 1,n = 0$ | 2        | 2        |
| 測試三   | $m = 2,n = 1$ | 5        | 5        |
| 測試四   | $m = 3,n = 2$ | 29       | 29       |
| 測試五   | $m = 5,n = 1$ | 異常拋出  | 異常拋出  |

### 結論

1. 僅管使用了堆疊以及unsigned long long但還是有一定的機會爆掉。
2. 程式所能執行的範圍大約在 m=4,n=1以上時就無法執行了不管是遞迴或是非遞迴，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$m = 0$、$ m和n不等於0 $），等驗證程式的正確性。

## 申論及開發報告

### 選擇堆疊的原因

1. **程式碼邏輯簡單**  
   Stack的寫法相當於自己管理堆疊且空間計算上能以最內層的資料計算最後在計算外層的資料避免執行錯誤。  
   例如：  
      empty()用於確認堆疊空間內是否還有資料,無資料代表計算結束。
      top()查看堆疊最上層的資料,如果a和b接不等於0時使用top()將最內層的A先行計算。
      m和n接不等於0的話:
        A.push(a - 1);//先放最外層的A
        A.push(a);//先算最內層的A
        b = b - 1;

2. **推疊的分析**  
   堆疊演算法（Stack） 是一種有序串列（即一群相同資料型態的組合），具有「後進先出」（Last In First Out, LIFO）的特性,故其所有的動作、資料的處理方式均在同一邊進行,
   同時實現了在大量測資運行時避免使用遞迴空間的浪費空間,而是把所有側資放放在同一個空間中。
   
3. **優缺點**
   優點：
   不用系統遞迴呼叫，因此可處理較大參數。
   控制流程更靈活。
 
   缺點：
   寫法較複雜。
   若數值太大,堆疊大小仍可能不足。

4. **理想推演**
   雖然每總解法都大同小異但在時間與空間的限制下要實現是有一定的複雜但下列這些方法是我找到有趣的解法之一 ! !
   1.利用「已知規律」或「特殊情況」進行公式化。
   2.include <map> 。
   3.鏈結串列節省空間。
